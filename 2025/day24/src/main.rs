use std::fs;

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
enum Value {
    Repeat {
        n: u64,
        v: u64,
    },
    Sequence {
        min_inclusive: u64,
        max_inclusive: u64,
    },
}

impl Value {
    fn sum(&self) -> u64 {
        match self {
            Value::Repeat { n, v } => n * v,
            Value::Sequence {
                min_inclusive,
                max_inclusive,
            } => max_inclusive * (max_inclusive + 1) / 2 - (min_inclusive - 1) * min_inclusive / 2,
        }
    }
}

fn push(n: u64, v: u64, layer: &mut Vec<Value>) {
    if let Some(last) = layer.last_mut() {
        match last {
            Value::Repeat {
                n: last_n,
                v: last_v,
            } => {
                if *last_v == v {
                    *last_n += n;
                } else if *last_n == 1 && *last_v + 1 == v {
                    let last_v = *last_v;
                    layer.pop();
                    layer.push(Value::Sequence {
                        min_inclusive: last_v,
                        max_inclusive: v,
                    })
                } else {
                    layer.push(Value::Repeat { n, v });
                }
            }

            Value::Sequence { max_inclusive, .. } => {
                if n == 1 && *max_inclusive + 1 == v {
                    *max_inclusive = v;
                } else {
                    layer.push(Value::Repeat { n, v });
                }
            }
        }
    } else {
        layer.push(Value::Repeat { n, v });
    }
}

fn main() {
    // I identified two patterns in the tree generated by the input file:
    // repeating numbers and monotonically increasing sequences. I optimized my
    // code for these two patterns. It runs in a reasonable time.

    let input = fs::read_to_string("input.txt").expect("Could not read file");
    let values = input
        .trim()
        .split_ascii_whitespace()
        .map(|v| v.parse::<u64>().unwrap())
        .collect::<Vec<_>>();

    // part 1
    let mut sum = 0;
    let mut layer = values.clone();
    while layer.len() > 1 {
        let mut new_layer = Vec::new();
        for w in layer.windows(2) {
            new_layer.push(w[0].max(w[1]) + 1);
        }
        sum += layer.iter().sum::<u64>();
        layer = new_layer;
    }
    sum += layer[0];
    println!("{sum}");

    // part 2
    let mut layer = Vec::new();
    for w in values.chunks_exact(5) {
        let mut a = w[0];
        let b = w[1];
        let c = w[2];
        let m = w[3];
        let n = w[4];
        for _ in 0..n {
            push(1, a, &mut layer);
            a = (b * a + c) % m;
        }
    }

    let mut total2 = layer.iter().map(|v| v.sum()).sum::<u64>();
    let mut new_layer: Vec<Value> = Vec::with_capacity(layer.len());
    while !layer.is_empty() {
        new_layer.clear();

        let mut prev: Option<u64> = None;
        for &val in &layer {
            match val {
                Value::Repeat { n, v } => {
                    if let Some(prev) = prev {
                        push(1, prev.max(v) + 1, &mut new_layer);
                    }

                    if n > 1 {
                        push(n - 1, v + 1, &mut new_layer);
                    }

                    prev = Some(v);
                }

                Value::Sequence {
                    min_inclusive,
                    max_inclusive,
                } => {
                    if let Some(prev) = prev {
                        push(1, prev.max(min_inclusive) + 1, &mut new_layer);
                    }

                    if max_inclusive > min_inclusive + 1 {
                        new_layer.push(Value::Sequence {
                            min_inclusive: min_inclusive + 2,
                            max_inclusive: max_inclusive + 1,
                        });
                    } else {
                        push(1, max_inclusive + 1, &mut new_layer);
                    }

                    prev = Some(max_inclusive);
                }
            }
        }

        total2 += new_layer.iter().map(|v| v.sum()).sum::<u64>();

        std::mem::swap(&mut layer, &mut new_layer);
    }
    println!("{total2}");
}
